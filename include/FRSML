#pragma once 

#ifdef _WIN32
#include <intrin.h>
typedef __int32 FRS_uint32;

#elif defined __unix__ 
#include <stdint.h>
#endif

#include <nmmintrin.h>
#include <functional>
#include <intrin.h>

#ifdef _WIN32
#ifdef FRSML_EXPORTS
#define TFAPI 
#else
#define TFAPI __declspec(dllimport)
#endif
#endif

#define EXP2_TABLE_SIZE_LOG2 9
#define MGNBR1 531.7555982144694 
#define MGNBR2 32.521961561056756
#define MGNBR3 9.47803843894324
#define MGNBR4 5040
#define LOG2 1.44269504088896340736 

#define PI 3.14159265358979323846264338327950288f
#define PI2 6.28318530717958647692528676655900577f
#define PID2 1.57079632679489661923132169163975144f
#define PISQ 9.86960440108935861883449099987615114f
#define HALFWISEANGLE FRS_float(180)

#define FLOAT_CONST(Key, v) \
    static const __declspec(align(16)) float _F_##Key[4] = { v,v,v, v }

#define INT_CONST(Key, v) \
    static const __declspec(align(16)) int _I_##Key[4] = {v, v, v, v}

FLOAT_CONST(1, 1.0f);
FLOAT_CONST(half, 0.5f);

FLOAT_CONST(cephes_log2, 1.44269504088896341);
FLOAT_CONST(cephes_c1, 0.693359375);
FLOAT_CONST(cephes_c2, -2.12194440e-4);

FLOAT_CONST(cephes_p0, 1.9875691500E-4);
FLOAT_CONST(cephes_p1, 1.3981999507E-3);
FLOAT_CONST(cephes_p2, 8.3334519073E-3);
FLOAT_CONST(cephes_p3, 4.1665795894E-2);
FLOAT_CONST(cephes_p4, 1.6666665459E-1);
FLOAT_CONST(cephes_p5, 5.0000001201E-1);

INT_CONST(min_norm_pos, 0x00800000);
INT_CONST(mant_mask, 0x7f800000);
INT_CONST(inv_mant_mask, ~0x7f800000);

INT_CONST(sign_mask, (int)0x80000000);
INT_CONST(inv_sign_mask, ~0x80000000);

//The min, max of the exp return
FLOAT_CONST(exp_upper, 88.3762626647949);
FLOAT_CONST(exp_lower, -88.3762626647949);

FLOAT_CONST(cephes_SQRTHF, 0.707106781186547524);
FLOAT_CONST(cephes_log_p0, 7.0376836292E-2);
FLOAT_CONST(cephes_log_p1, -1.1514610310E-1);
FLOAT_CONST(cephes_log_p2, 1.1676998740E-1);
FLOAT_CONST(cephes_log_p3, -1.2420140846E-1);
FLOAT_CONST(cephes_log_p4, +1.4249322787E-1);
FLOAT_CONST(cephes_log_p5, -1.6668057665E-1);
FLOAT_CONST(cephes_log_p6, +2.0000714765E-1);
FLOAT_CONST(cephes_log_p7, -2.4999993993E-1);
FLOAT_CONST(cephes_log_p8, +3.3333331174E-1);
FLOAT_CONST(cephes_log_q1, -2.12194440e-4);
FLOAT_CONST(cephes_log_q2, 0.693359375);

#define MASK3 255
#define MASK2 170
#define MASK1 85
#define MASK0 0

INT_CONST(triplemask, 0x7f);

//Get NOT of 32-bit signed int
//Add to the library of mmintrin
__m128i TFAPI _mm_not_epi32(__m128i _A);

//Get NOT of a float
//Add to the library of mmintrin
float TFAPI _mm_extract_psn(__m128 a, int pos);
__m128 TFAPI  _mm_not_ps(__m128 _A);
__m128i TFAPI _mm_div_epi32(__m128i _para1, __m128i ant);

template class TFAPI std::function<__m128(__m128)>;
template class TFAPI std::function<__m128(__m128, __m128)>;
typedef std::function<__m128(__m128)> TF_MATH_FUNC;
typedef std::function<__m128(__m128, __m128)> TF_MATH_FUNC2;

#ifdef USE_DECREPATED
//Wrapper of SSE var
#define FRSML_PI 3.14159265358979323846  
#define FRSML_PI_D2 1.57079632679489661923      
#define FRSML_PI_D4 0.785398163397448309616  

#ifdef _WIN32
#ifdef FRSML_EXPORTS
#define TFAPI
#else
#define TFAPI __declspec(dllimport)
#endif
#endif

//Division of high and up byte using these magical number
//Suffle thing will be fun with this
static const __m128i magicIntNum = _mm_set1_epi16(0x4B00);
static const __m128 magicFloatNum = _mm_set_ps1(8388608.0f);


//Forgive me, halation!
struct TFAPI FRS_float {
public:

	FRS_float(float n = 0) {
		//Forgive me, again, they didnt give me a choice!
		mainNum = _mm_load_ss(&n);
	}

	FRS_float(__m128 n) {
		mainNum = n;
	}

	void operator =(float need) {
		mainNum = _mm_load_ss(&need);
	}

	__m128& MainNum() {
		return mainNum;
	}

	FRS_float operator + (FRS_float f1);
	FRS_float operator - (FRS_float f1);
	FRS_float operator * (FRS_float f1);
	FRS_float operator / (FRS_float f1);

	FRS_float operator + (float f1);
	FRS_float operator - (float f1);
	FRS_float operator * (float f1);
	FRS_float operator / (float f1);

	void operator += (float n);
	void operator -= (float n);
	void operator *= (float n);
	void operator /= (float n);
	void operator++();
	void operator--();
	bool operator == (FRS_float ant);
	bool operator !=(FRS_float ant);
	FRS_float operator |(FRS_float ant);
	FRS_float operator &(FRS_float ant);
	FRS_float operator ^(FRS_float ant);
	void operator |=(FRS_float ant);
	void operator &=(FRS_float ant);
	void operator ^=(FRS_float ant);
	bool operator >(FRS_float ant);
	bool operator >=(FRS_float ant);
	bool operator <(FRS_float ant);
	bool operator <=(FRS_float ant);


	explicit operator float() const;

	static FRS_float get_128b_ff(float& n);

private:
	__m128 mainNum;
};


//A int array is nothing like this. Forgive me, again!
struct TFAPI FRS_int {
public:

	FRS_int(__m128i n) {
		mainInt = n;
	}

	FRS_int(int n = 0) {
		mainInt = _mm_set1_epi32(n);
	}

	void operator = (int& a) {
		int* n = (int*)(&mainInt);
		a = n[1];
	}

	explicit operator int() const {
		return _mm_cvtsi128_si32(this->mainInt);
	}



	__m128i& MainNum() {
		return mainInt;
	}

	FRS_int operator + (FRS_int f1);
	FRS_int operator - (FRS_int f1);
	FRS_int operator * (FRS_int f1);
	FRS_int operator /(FRS_int f1);
	void operator += (int n);
	void operator -= (int n);
	void operator *= (int n);
	void operator /=(int n);


	void operator++();
	void operator--();
	void operator =(int n);


	bool operator ==(FRS_int& ant);
	bool operator !=(FRS_int& ant);
	bool operator >(FRS_int& ant);
	bool operator >=(FRS_int& ant);
	bool operator <(FRS_int& ant);
	bool operator <=(FRS_int& ant);

	FRS_int operator |(FRS_int ant);
	FRS_int operator &(FRS_int ant);
	FRS_int operator ^(FRS_int ant);

	void operator |=(FRS_int ant);
	void operator &=(FRS_int ant);
	void operator ^=(FRS_int ant);

	FRS_int operator <<(int a);
	FRS_int operator >>(int a);

	void operator <<=(int a);
	void operator >>=(int a);

	static FRS_int set_128bi_fi(int& n);
	static int get_i_f128bi(FRS_int& i);


private:
	__m128i mainInt;
};


TFAPI std::ostream& operator <<(std::ostream& para, const FRS_float& a);
TFAPI std::istream& operator >>(std::istream& para, FRS_float& a);
TFAPI std::ostream& operator <<(std::ostream& para, const FRS_int& a);
TFAPI std::istream& operator >>(std::istream& para, FRS_int& a);


TFAPI FRS_float ConvertToFloat(FRS_int ant);

TFAPI FRS_int ConvertToInt(FRS_float ant);


#endif

#ifdef INCLUDE_CPUID
//Check if set of extensions are supported on the platform
//Support now: Windows
struct TFAPI CPUID {
public:
#pragma region INSTRICTS_MATH_SUPPORT



	static bool FRS_MMX;
	static bool FRS_x64;
	static bool FRS_ABM;
	static bool FRS_RDRAND;
	static bool FRS_BMI1;
	static bool FRS_BMI2;
	static bool FRS_ADX;
	static bool FRS_PREFETCHWT1;

	static bool FRS_SSE;
	static bool FRS_SSE2;
	static bool FRS_SSE3;
	static bool FRS_SSSE3;
	static bool FRS_SSE41;
	static bool FRS_SSE42;
	static bool FRS_SSE4A;
	static bool FRS_AES;
	static bool FRS_SHA;

	static bool FRS_AVX;
	static bool FRS_XOP;
	static bool FRS_FMA3;
	static bool FRS_FMA4;
	static bool FRS_AVX2;

	static bool FRS_AVX512F;
	static bool FRS_AVX512CD;
	static bool FRS_AVX512PF;
	static bool FRS_AVX512ER;
	static bool FRS_AVX512VL;
	static bool FRS_AVX512BW;
	static bool FRS_AVX512DQ;
	static bool FRS_AVX512IFMA;
	static bool FRS_AVX512VBMI;
	static bool WINDOWS_64BIT;

#pragma endregion

	//- Start check CPU extensions
	static void StartDetectCPUFeaturesAndExtensions();
	//- Check if CPU detection whether has been started, 
	//to check information about CPU extensions
	static bool HasCPUDetectionStarted();

private:
	static FRS_uint32 registers[4];
	static bool StartedDetectQuestionMark;
};


#endif

namespace FRSML{


	//I dont love _mm_shuffle so much, it's mask is __
	//A Vector2 class SIMD
	class TFAPI vec2 {
	public:

		vec2(__m128 _para);
		vec2(float x, float y);
		vec2(float n = 0);

		__m128& MainVector() {
			return mainVec;
		}

		float X, Y;

		inline bool operator == (vec2 ant);
		inline bool operator != (vec2 ant);

		inline vec2 operator +(vec2 ant);
		inline void operator +=(vec2 ant);
		inline vec2 operator + (float ant);
		inline void operator += (float ant);
		inline void operator ++();
		inline vec2 operator -(vec2 ant);
		inline vec2 operator -(float ant);
		inline void operator -=(vec2 ant);
		inline void operator -=(float ant);
		inline void operator --();
		inline vec2 operator *(vec2 ant);
		inline vec2 operator *(float ant);
		inline void operator *=(vec2 ant);
		inline void operator *=(float ant);
		inline vec2 operator /(vec2 ant);
		inline vec2 operator /(float ant);
		inline void operator /=(vec2 ant);
		inline void operator /=(float ant);

		inline vec2 operator &(vec2 ant);
		inline void operator &=(vec2 ant);
		inline vec2 operator ^(vec2 ant);
		inline void operator ^=(vec2 ant);
		inline vec2 operator |(vec2 ant);
		inline void operator |=(vec2 ant);

		//@ Return the length of a Vector2 vec
		//Using dot product with mask = 0x31 = 0011 0001, 
		//we can dot 3 floats with themselves and put it in the lowest bit.
		inline float Length();

		static vec2 Down;
		static vec2 Up;
		static vec2 Left;
		static vec2 Right;

		operator float*() const {

			float* value;
			value[0] = mainVec.m128_f32[3];
			value[1] = mainVec.m128_f32[2];

			return value;
		}

		friend float* value_ptr(vec2 vec);

		inline vec2 Normalize();

	private:

		void SetRealXY(float newX, float newY) {
			X = newX;
			Y = newY;
		}

		void SetRealXY(__m128 _para) {
			X = _para.m128_f32[1];
			Y = _para.m128_f32[0];
		}

		__m128 mainVec;
	};

	//A Vector3 class SIMD
	class TFAPI vec3 {
	public:
		vec3(__m128 _para);
		vec3(float x, float y, float Z);
		vec3(float n = 0);

		__m128& MainVector() {
			return mainVec;
		}

		float X, Y, Z = 0;

		inline bool operator == (vec3 ant);
		inline bool operator != (vec3 ant);
		inline vec3 operator +(vec3 ant);

		inline void operator +=(vec3 ant) {
			mainVec = _mm_add_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}

		inline vec3 operator + (float ant);
		inline void operator += (float ant) {
			mainVec = _mm_sub_ps(mainVec, _mm_set1_ps(ant));
			SetRealXY(mainVec);
		}
		inline void operator ++() {
			mainVec = _mm_add_ps(mainVec, _mm_set1_ps(1));
			SetRealXY(mainVec);
		}
		inline vec3 operator -(vec3 ant);
		inline vec3 operator -(float ant);
		inline void operator -=(vec3 ant) {
			mainVec = _mm_sub_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}
		inline void operator -=(float ant) {
			mainVec = _mm_sub_ps(mainVec, _mm_set1_ps(ant));
			SetRealXY(mainVec);
		}
		inline void operator --() {
			mainVec = _mm_sub_ps(mainVec, _mm_set1_ps(1));
			SetRealXY(mainVec);
		}
		inline vec3 operator *(vec3 ant);
		inline vec3 operator *(float ant);
		inline void operator *=(vec3 ant) {
			mainVec = _mm_mul_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}
		inline void operator *=(float ant) {
			mainVec = _mm_mul_ps(mainVec, _mm_set1_ps(ant));
			SetRealXY(mainVec);
		}
		inline vec3 operator /(vec3 ant);
		inline vec3 operator /(float ant);
		inline void operator /=(vec3 ant) {
			mainVec = _mm_div_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}
		inline void operator /=(float ant) {
			mainVec = _mm_div_ps(mainVec, _mm_set1_ps(ant));
			SetRealXY(mainVec);
		}

		inline vec3 operator &(vec3 ant);
		inline void operator &=(vec3 ant) {
			mainVec = _mm_and_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}
		inline vec3 operator ^(vec3 ant);
		inline void operator ^=(vec3 ant) {
			mainVec = _mm_xor_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}
		inline vec3 operator |(vec3 ant);
		inline void operator |=(vec3 ant) {
			mainVec = _mm_or_ps(mainVec, ant.mainVec);
			SetRealXY(mainVec);
		}

		static vec3 Down;
		static vec3 Forward;
		static vec3 Backward;
		static vec3 Up;
		static vec3 Left;
		static vec3 Right;

		friend float* value_ptr(vec3 vec);
		//@ Return the length of a Vector3 vec
		//Using dot product with mask = 0x71 = 0111 0001, 
		//we can dot 3 floats with themselves and put it in the lowest bit.
		inline float Length();

		inline vec3 Normalize();

		operator float*() const {

			float* value;
			value[0] = mainVec.m128_f32[3];
			value[1] = mainVec.m128_f32[2];
			value[2] = mainVec.m128_f32[1];

			return value;
		}

	private:
		__m128 mainVec;

		void SetRealXY(float newX, float newY, float newZ) {
			X = newX;
			Y = newY;
			Z = newZ;
		}

		void SetRealXY(__m128 _para) {
			X = _para.m128_f32[2];
			Y = _para.m128_f32[1];
			Z = _para.m128_f32[0];
		}

	};


	class TFAPI vec4 {
	public:

		vec4(float ant = 0);
		vec4(float x, float y, float z, float w);
		vec4(float* as);
		vec4(vec3 _para, float _para2);

		__m128& MainVector();
		vec4(__m128 _set);
		void operator =(vec4 ant);
		bool operator ==(vec4 ant);
		vec4 operator +(vec4 ant);
		vec4 operator -(vec4 ant);
		void operator -=(vec4 ant) {
			*this = *this - ant;
			SetRealXY(mainVec);
		}

		void operator +=(vec4 ant) {
			*this = *this - ant;
			SetRealXY(mainVec);
		}

		void operator *=(vec4 ant) {
			*this = *this * ant;
			SetRealXY(mainVec);
		}

		void operator /=(vec4 ant) {
			*this = *this / ant;
			SetRealXY(mainVec);
		}

		vec4 operator *(vec4 ant);
		vec4 operator /(vec4 ant);
		vec4 operator +(float ant);
		vec4 operator -(float ant);
		vec4 operator *(float ant);
		vec4 operator /(float ant);
		void operator /=(float ant) {
			*this = *this / ant;
			SetRealXY(mainVec);
		}

		friend float* value_ptr(vec4 vec);

		float X, Y, Z, W = 0;

		float Length();
		vec4 Normalize();

		operator float*() const {

			float* value;
			value[0] = mainVec.m128_f32[3];
			value[1] = mainVec.m128_f32[2];
			value[2] = mainVec.m128_f32[1];
			value[3] = mainVec.m128_f32[0];

			return value;
		}

	private:
		__m128 mainVec;

		void SetRealXY(float newX, float newY, float newZ, float newW) {
			X = newX;
			Y = newY;
			Z = newZ;
			W = newW;
		}

		void SetRealXY(__m128 _para) {
			X = _para.m128_f32[3];
			Y = _para.m128_f32[2];
			Z = _para.m128_f32[1];
			W = _para.m128_f32[0];
		}

	};

	class TFAPI vec4i {
	public:

		vec4 ConvertToVector4f();

		vec4i(__m128i _gene);

		//vec4i(FRS_int ant);


		vec4i(int x, int y, int w, int z);

		vec4i(int t = 0);

		int& X();

		int& Y();

		int& Z();

		int& W();

		void operator =(vec4i ant);

		vec4i operator ==(vec4i ant);


#pragma region OPERATOR

		vec4i operator + (vec4i ant);
		vec4i operator -(vec4i ant);
		vec4i operator * (vec4i ant);
		vec4i operator /(vec4i ant);

		vec4i operator +(int ant);
		vec4i operator -(int ant);
		vec4i operator *(int ant);
		vec4i operator /(int ant);

		void operator +=(vec4i ant);

		void operator -=(vec4i ant);

		void operator *=(vec4i ant);

		void operator +=(int ant);

		void operator -=(int ant);

		void operator *=(int ant);

		void operator /=(int ant);

		vec4i operator &(vec4i ant);

		void operator &=(vec4i ant);

		vec4i operator ^(vec4i ant);

		void operator ^=(vec4i ant);

		vec4i operator |(vec4i ant);

		void operator |=(vec4i ant);

		float Length();

		__m128i& MainVector();

#pragma endregion

	private:
		__m128i mainVec;
		void _frs_getmagnum_i(int divisor, __m128i& mul, __m128i& shift1, __m128i& sign);

	};

	float TFAPI ToDegrees(float radians);
	float TFAPI ToRadians(float degrees);

	namespace nmmintrin {
		TFAPI __m128i _Abs(__m128i _para);
		TFAPI __m128 _Absf(__m128 m);
		TFAPI __m128 _Maxf(__m128 _A, __m128 _B);
		TFAPI __m128 _Minf(__m128 _A, __m128 _B);
		TFAPI __m128i _Max(__m128i _A, __m128i _B);
		TFAPI __m128i _Min(__m128i _A, __m128i _B);
		TFAPI __m128 _Sqrtf(__m128 ant);
		TFAPI __m128i _Sqrt(__m128i ant);
		TFAPI __m128 _Signf(__m128 _para);
		inline TFAPI __m128 BalanceToPiDistance(__m128 _para);
		inline TFAPI __m128 _Sin(__m128 _para);
		inline TFAPI __m128 _Cos(__m128 _para);
		inline TFAPI __m128 _Tan(__m128 _para);
		inline TFAPI __m128 _Cot(__m128 _para);
		inline TFAPI __m128 _Asin(__m128 _para);
		inline TFAPI __m128 _Acos(__m128 _para);
		inline TFAPI __m128 _Atan2(__m128 _Y, __m128 _X);
		inline TFAPI __m128 _Atan(__m128 _X);
		inline TFAPI __m128 _Pow(__m128 x, __m128 y);
		//My mom tells me something different. Dont tell her i do thiz
		//This was probally a dick move of mine. But the documentation is old
		//And i just port this code from cmath source. Sorry :P
		inline TFAPI __m128 _Exp(__m128 _para);
		inline TFAPI __m128 _Log(__m128 _para);
	}

	template <class T> T _funcWrp1p(TF_MATH_FUNC func, T _para) {
		return T(func(_para.MainVector()));
	}

	template <class T> T _funcWrp2p(TF_MATH_FUNC2 func, T _para1, T _para2) {
		return T(func(_para1.MainVector(), _para2.MainVector()));
	}

	//Get the absolute value of a vec2
	TFAPI vec2 Abs(vec2 _para);

	//Get the absolute value of a vec3
	TFAPI vec3 Abs(vec3 _para);

	//Get the absolute value of a vec4
	TFAPI vec4 Abs(vec4 _para);

	//Get the Min value between two vec2 Vector
	TFAPI vec2 Min(vec2 _para1, vec2 _para2);

	//Get the Max value between two vec2 Vector
	TFAPI vec2 Max(vec2 _para1, vec2 _para2);

	//Get the Min value between two vec3 Vector
	TFAPI vec3 Min(vec3 _para1, vec3 _para2);

	//Get the Max value between two vec3 Vector
	TFAPI vec3 Max(vec3 _para1, vec3 _para2);

	//Get the Min value between two vec4 Vector
	TFAPI vec4 Min(vec4 _para1, vec4 _para2);

	//Get the Max value between two vec4 Vector
	TFAPI vec4 Max(vec4 _para1, vec4 _para2);

	//Get the cross product of two vec3
	TFAPI vec3 Cross(vec3 _para1, vec3 _para2);

	//Get the dot product of two vec2
	TFAPI vec2 Dot(vec2 _para1, vec2 _para2);

	//Get the dot product of two vec3
	TFAPI vec3 Dot(vec3 _para1, vec3 _para2);

	//Get the dot product of two vec4
	TFAPI vec4 Dot(vec4 _para1, vec4 _para2);

	//Get the cross product of two vec2
	TFAPI vec2 Dot(vec2 _para1, vec2 _para2);

	//Get the angle create between two vec2
	TFAPI vec2 Angle(vec2 _para1, vec2 _para2);

	//Get the angle create between two vec3
	TFAPI vec3 Angle(vec3 _para1, vec3 _para2);


	//Get the angle create between two vec4
	TFAPI vec4 Angle(vec4 _para1, vec4 _para2);

	//Reflect the Vector with direction and normal
	TFAPI vec2 Reflect(vec2 inDir, vec2 inNorm);

	//Reflect the Vector with direction and normal
	TFAPI vec3 Reflect(vec3 inDir, vec3 inNorm);

	//Reflect the Vector with direction and normal
	TFAPI vec4 Reflect(vec4 inDir, vec4 inNorm);

	//Return the distance between two Vector!!!!!!
	TFAPI float Distance(vec2 _start, vec2 _end);

	//Return the distance between two Vector!!!!!!
	TFAPI float Distance(vec3 _start, vec3 _end);

	//Return the distance between two Vector!!!!!!
	TFAPI float Distance(vec4 _start, vec4 _end);


#ifdef USE_DECREPATED
	//Caculate the absolute value of an int! Using SSE tech! Whoa!
	TFAPI FRS_int Abs(FRS_int _para);

	//Caculate the absolute value of a float! Using SSE tech! Whoa!
	TFAPI  FRS_float Abs(FRS_float _para);
#endif

	//Cacluate the e^x value
	TFAPI double Exp(double x);

	//Caculate the logarithym value base e
	TFAPI float Log(float x);

	//Caculate the logarithym value base 2
	TFAPI float Log2(float x);

	//Caculate the logarithym value base "base"
	TFAPI float Log(float x, float base);

	//Caculate x^y;
	TFAPI float Pow(float x, float y);

#ifdef USE_DECREPATED

	//Get the Square Root value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Sqrt(FRS_int ant);

	//Get the Square Root value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Sqrt(FRS_float ant);

	//Get the Max value between two int
	TFAPI FRS_int Max(FRS_int _A, FRS_int _B);

	//Get the Min value between two int
	TFAPI FRS_int Min(FRS_int _A, FRS_int _B);

	//Get the Max value between two float
	TFAPI FRS_float Max(FRS_float _A, FRS_float _B);

	//Get the Min value between two float
	TFAPI FRS_float Min(FRS_float _A, FRS_float _B);

	//Get the Sin value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Sin(FRS_float _A);

	//Get the Cos value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Cos(FRS_float _A);

	//Get the Tan value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Tan(FRS_float _A);

	//Get the Cotan value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Cot(FRS_float _A);

	//Get the Asin value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Asin(FRS_float _A);

	//Get the Acos value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Acos(FRS_float _A);

	TFAPI FRS_float Atan2(FRS_float _A, FRS_float _B);

	//Get the Atan value of a float using SSE
	//Whoa, technology!
	TFAPI FRS_float Atan(FRS_float _A);

	//Get the Sin value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Sin(FRS_int _A);

	//Get the Cos value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Cos(FRS_int _A);

	//Get the Tan value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Tan(FRS_int _A);

	//Get the Cotan value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Cot(FRS_int _A);

	//Get the Asin value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Asin(FRS_int _A);

	//Get the Acos value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Acos(FRS_int _A);

	//Atan2 cacluates the degrees of the angle created
	//between coordinate line (origin to point2d line) and axis
	//Or basicly, it is Arctan of (-y/-x); And its tech is SSE!
	//Whoa!
	TFAPI FRS_float Atan2(FRS_int _X, FRS_int _Y);

	//Get the Atan value of an int using SSE
	//Whoa, technology!
	TFAPI FRS_float Atan(FRS_int _A);
#endif
	//Caculate the absolute value of a float! Using SSE tech! Whoa!
	TFAPI float Abs(float _para);

	//Clamp the value
	TFAPI float Clamp(float _t1, float _t2, float crrNumber);

	//Return the value between a and b. Basically, t is the percent in short written
	TFAPI float Lerp(float t, float a, float b);

	//I dont think it makes things faster than normal, so throw it here ^-^
	//It caculate the Sign of a float. Whoa technology!
	TFAPI float Sign(float _para);

	//Get the Sin value of a float using SSE
	//Whoa, technology!
	TFAPI float Sin(float _para);

	//Get the Cos value of a float using SSE
	//Whoa, technology!
	TFAPI float Cos(float _para);

	//Get the Tan value of a float using SSE
	//Whoa, technology!
	TFAPI float Tan(float _para);

	//Get the Cotan value of a float using SSE
	//Whoa, technology!
	TFAPI float Cot(float _para);

	//The sin value of X will be put into "s" array
	//The cos value of Y will be put into "c" array
	//... Using SSE technology! Whoa!
	TFAPI void SinCos(float x, float* s, float* c);

	//Get the Asin value of a float using SSE
	//Whoa, technology!
	TFAPI float Asin(float _para);

	//Get the Acos value of a float using SSE
	//Whoa, technology!
	TFAPI float Acos(float _para);


	//Get the Atan value of a float using SSE
	//Whoa, technology!
	TFAPI float Atan(float _para);

	//Atan2 cacluates the degrees of the angle created
	//between coordinate line (origin to point2d line) and axis
	//Or basicly, it is Arctan of (-y/-x); And its tech is SSE!
	//Whoa!
	TFAPI float Atan2(float _X, float _Y);

	//Get the Max value between two float
	TFAPI float Max(float _A, float _B);

	//Get the Max value between two float
	TFAPI float Min(float _A, float _B);

	//Get the Square Root value of a float using SSE
	//Whoa, technology!
	TFAPI float Sqrt(float ant);

	class TFAPI Matrix4 {
	public:
		Matrix4(float** rowContent);
		Matrix4(float* row1, float* row2, float* row3, float* row4);
		Matrix4(float n = 0);
		Matrix4(vec4 row1, vec4 row2, vec4 row3, vec4 row4);

		bool IsMatrixIndentiy();

		Matrix4 Transpose();
		float Determinant();

		//Wrapper to return the member number of Matrix
		struct Matrix4Proxy
		{
			Matrix4* matrix;
			int matrixIndex1;

			Matrix4Proxy(Matrix4 *mat, int i) : matrix(mat), matrixIndex1(i) {}

			//I do not feel sastified with this :-(
			float& operator [](std::size_t matrixIndex2)
			{
				return matrix->rows[matrixIndex1].MainVector().m128_f32[3 - matrixIndex2];
			}

		};

		friend Matrix4 Translate(Matrix4 base, vec3 trans);

		//Rotate a matrix with axis
		//You can use Quaternion instead. I'm also provide an converter of Euler vector
		friend Matrix4 Rotate(Matrix4 base, float rot, vec3 dir);

		friend Matrix4 Scale(Matrix4 base, float scale);

		friend float** value_ptr(Matrix4 mat);

		//Return the number given by its position
		Matrix4Proxy operator[](std::size_t i) {
			return Matrix4Proxy(this, i);
		}

		//Very sad that this method is o(n^3), but i can just understand this max.
		Matrix4 Inverse();


		inline Matrix4 operator *(Matrix4 _para);
		
		inline void operator *= (Matrix4 _para){
			*this = *this * _para;
		}
		
		inline Matrix4 operator +(Matrix4 _para);
		inline Matrix4 operator -(Matrix4 _para);

	private:
		vec4 rows[4] = {};
		vec4 cols[4] = {};


	};

	static Matrix4 Identity{
		{ 1,0,0,0 },
		{ 0,1,0,0 },
		{ 0,0,1,0 },
		{ 0,0,0,1 }
	};

	static Matrix4 Zero{
		{ 0,0,0,0 },
		{ 0,0,0,0 },
		{ 0,0,0,0 },
		{ 0,0,0,0 }
	};

	TFAPI Matrix4 CreatePerspectiveMatrix(float zoom,
		vec2 extent,
		float zNear,
		float zFar);

	TFAPI Matrix4 CreateOrthoMatrix(float left,
		float right, float bottom,
		float top, float zNear, float zFar);

	//I have the up vector already.
	TFAPI Matrix4 LookAt(vec3 camPos, vec3 camTarget);

	TFAPI std::ostream& operator <<(std::ostream&, Matrix4);

	using namespace nmmintrin;

	class TFAPI Quaternion {
	public:
		Quaternion(float x = 0, float y = 0, float z = 0, float w = 1){
			mainQuat = _mm_set_ps(w, x, y, z);
		}

		Quaternion(__m128 quatVal) {
			mainQuat = quatVal;
		}
		

		operator Matrix4();


		float& X(); float& Y(); float& Z(); float& W();

		inline static Quaternion Euler(vec3 euler);
		inline static Quaternion Rotate(vec3 axis, float angle);

		//Add two quaternion
		inline Quaternion operator +(Quaternion tar1);

		//Multi-quat!! Get it?
		inline Quaternion operator *(Quaternion tar1);
		Quaternion Normalize();

	private:
		__m128 mainQuat;
	};

	//Get the dot product of two Quaternion
	TFAPI Quaternion Dot(Quaternion _para1, Quaternion _para2);

	//Get the angle create between two Quaternion
	TFAPI Quaternion Angle(Quaternion _para1, Quaternion _para2);


}

